---
title: "Challenge_hein"
author: "Hein Brouwer"
date: "2025-03-17"
output: html_document
---

```{r packages}
#install.packages("igraph")
#install.packages("RColorBrewer")
library(igraph)
library(RColorBrewer)
library(visNetwork)
```

```{r facebooknetwork}
#build Facebook network
Facebook_edge<-read.csv("Facebook_edge.csv",header=FALSE)
Facebook_att<-read.csv("Facebook_att.csv",header = TRUE)
Facebook_nodes<-data.frame(name=as.character(Facebook_att$NodeID),
                           gender=as.character(Facebook_att$sex),
                           group=as.character(Facebook_att$group))
Facebook_edges<-data.frame(from=c(as.character(Facebook_edge[,1])),
                           to=c(as.character(Facebook_edge[,2])))

Facebook<-graph_from_data_frame(Facebook_edges,directed = FALSE,vertices = Facebook_nodes)
summary(Facebook)

```
```{r highschoolnetwork}
#build high school network
highschool_edge<-read.csv("Highschool_network_edge.csv",header=FALSE)
highschool_att<-read.csv("Highschool_network_att.csv",header = TRUE)

highschool_nodes<-data.frame(name=as.character(highschool_att$NodeID),
                             gender=as.character(highschool_att$Gender),
                             hall=as.character(highschool_att$Hall))
highschool_edges<-data.frame(from=c(as.character(highschool_edge[,1])),
                             to=c(as.character(highschool_edge[,2])))
Highschool<-graph_from_data_frame(highschool_edges,directed = FALSE,vertices = highschool_nodes)
co <- components(Highschool)
Highschool <- induced_subgraph(Highschool, which(co$membership == which.max(co$csize))) #use only the largest component for analysis
summary(Highschool)

```
```{r Q1}
# Analysis of shortest path lengths and degree distributions
library(ggplot2)

# Calculate shortest path lengths for Facebook network
facebook_distances <- distances(Facebook)
# Count pairs that can be reached within 6 steps
facebook_within_6 <- sum(facebook_distances <= 6 & facebook_distances > 0)
# Total possible pairs
facebook_total_pairs <- vcount(Facebook) * (vcount(Facebook) - 1)
# Calculate percentage
facebook_percentage <- (facebook_within_6 / facebook_total_pairs) * 100

# Calculate shortest path lengths for Highschool network
highschool_distances <- distances(Highschool)
# Count pairs that can be reached within 6 steps
highschool_within_6 <- sum(highschool_distances <= 6 & highschool_distances > 0)
# Total possible pairs
highschool_total_pairs <- vcount(Highschool) * (vcount(Highschool) - 1)
# Calculate percentage
highschool_percentage <- (highschool_within_6 / highschool_total_pairs) * 100

# Print results
cat("Facebook network:\n")
cat("Total nodes:", vcount(Facebook), "\n")
cat("Total edges:", ecount(Facebook), "\n")
cat("Percentage of node pairs reachable within 6 steps:", round(facebook_percentage, 2), "%\n")
cat("Maximum shortest path length:", max(facebook_distances[facebook_distances < Inf]), "\n\n")

cat("Highschool network:\n")
cat("Total nodes:", vcount(Highschool), "\n")
cat("Total edges:", ecount(Highschool), "\n")
cat("Percentage of node pairs reachable within 6 steps:", round(highschool_percentage, 2), "%\n")
cat("Maximum shortest path length:", max(highschool_distances[highschool_distances < Inf]), "\n\n")

# Analyze degree distributions
facebook_degrees <- degree(Facebook)
highschool_degrees <- degree(Highschool)

# Calculate summary statistics
facebook_degree_stats <- summary(facebook_degrees)
highschool_degree_stats <- summary(highschool_degrees)

cat("Facebook degree distribution:\n")
print(facebook_degree_stats)
cat("\nHighschool degree distribution:\n")
print(highschool_degree_stats)

# Plot degree distributions
par(mfrow=c(1,2))

# Facebook degree distribution
hist(facebook_degrees, 
     main="Facebook Degree Distribution", 
     xlab="Degree", 
     col="lightblue", 
     breaks=20)

# Highschool degree distribution
hist(highschool_degrees, 
     main="Highschool Degree Distribution", 
     xlab="Degree", 
     col="lightgreen", 
     breaks=15)

# Compute average path lengths
facebook_avg_path <- average.path.length(Facebook)
highschool_avg_path <- average.path.length(Highschool)

cat("\nAverage path length in Facebook network:", round(facebook_avg_path, 2), "\n")
cat("Average path length in Highschool network:", round(highschool_avg_path, 2), "\n")

# Compute diameter (longest shortest path)
facebook_diameter <- diameter(Facebook)
highschool_diameter <- diameter(Highschool)

cat("Diameter of Facebook network:", facebook_diameter, "\n")
cat("Diameter of Highschool network:", highschool_diameter, "\n")
```
```{r Q2}
# 1. Calculate modularity based on gender
genderCommunity <- V(Highschool)$gender
genderCommunity <- replace(genderCommunity, genderCommunity=="female", 1)
genderCommunity <- replace(genderCommunity, genderCommunity=="male", 2)
genderCommunity <- replace(genderCommunity, genderCommunity=="unknown", 3)
genderCommunity <- as.numeric(genderCommunity)
gender.clustering <- make_clusters(Highschool, membership=genderCommunity)
gender_modularity <- modularity(Highschool, membership=genderCommunity)
cat("Modularity when community is defined by gender:", gender_modularity, "\n")

# Calculate number of nodes in each gender community
gender_counts <- table(genderCommunity)
print(gender_counts)

# 2. Calculate modularity based on residential hall
hallCommunity <- V(Highschool)$hall
# Convert hall names to numeric IDs
unique_halls <- unique(hallCommunity)
hall_ids <- 1:length(unique_halls)
names(hall_ids) <- unique_halls
hallCommunity_numeric <- hall_ids[hallCommunity]
hall.clustering <- make_clusters(Highschool, membership=hallCommunity_numeric)
hall_modularity <- modularity(Highschool, membership=hallCommunity_numeric)
cat("Modularity when community is defined by residential hall:", hall_modularity, "\n")

# Calculate number of nodes in each hall community
hall_counts <- table(hallCommunity)
print(hall_counts)

# 3. Apply Louvain algorithm for community detection
Louv <- cluster_louvain(Highschool)
louv_modularity <- modularity(Louv)
cat("Modularity using Louvain community detection:", louv_modularity, "\n")

# Calculate number of communities and their sizes from Louvain algorithm
louv_membership <- membership(Louv)
louv_counts <- table(louv_membership)
cat("Number of communities detected by Louvain algorithm:", length(louv_counts), "\n")
print(louv_counts)

# Create visualization of networks with different community structures
# 1. Gender-based communities
plot1 <- plot(Highschool, 
     vertex.color=genderCommunity, 
     vertex.size=5, 
     vertex.label=NA, 
     main="Communities based on Gender")

# 2. Hall-based communities
plot2 <- plot(Highschool, 
     vertex.color=hallCommunity_numeric, 
     vertex.size=5, 
     vertex.label=NA, 
     main="Communities based on Residential Hall")

# 3. Louvain-detected communities
plot3 <- plot(Highschool, 
     vertex.color=louv_membership, 
     vertex.size=5, 
     vertex.label=NA, 
     main="Communities detected by Louvain algorithm")

# Analyze the differences between community structures
cat("\nAnalysis of Community Structures:\n")
cat("1. Gender-based communities:", length(unique(genderCommunity)), "communities\n")
cat("2. Hall-based communities:", length(unique(hallCommunity_numeric)), "communities\n")
cat("3. Louvain-detected communities:", length(unique(louv_membership)), "communities\n")

# Calculate the distribution of shortest path lengths
dist_matrix <- distances(Highschool)
path_lengths <- dist_matrix[lower.tri(dist_matrix)]
path_lengths <- path_lengths[is.finite(path_lengths)]  # Remove Inf values if any

# Histogram of shortest path lengths
hist(path_lengths, 
     main="Distribution of Shortest Path Lengths in Highschool Network", 
     xlab="Path Length", 
     col="lightblue", 
     breaks=max(path_lengths))

# Calculate degree distribution
deg <- degree(Highschool)

# Histogram of degree distribution
hist(deg, 
     main="Degree Distribution in Highschool Network", 
     xlab="Degree", 
     col="lightgreen", 
     breaks=15)

# Add a vertical line at the mean degree
abline(v=mean(deg), col="red", lwd=2, lty=2)
text(mean(deg) + 1, max(hist(deg, plot=FALSE)$counts) * 0.8, 
     paste("Mean =", round(mean(deg), 2)), col="red")

# Add lines for percentiles
quantiles <- quantile(deg, probs=c(0.25, 0.5, 0.75))
abline(v=quantiles[1], col="blue", lwd=2, lty=3)
abline(v=quantiles[2], col="blue", lwd=2, lty=1)
abline(v=quantiles[3], col="blue", lwd=2, lty=3)

text(quantiles[1] - 0.5, max(hist(deg, plot=FALSE)$counts) * 0.7, 
     "25%", col="blue")
text(quantiles[2] - 0.5, max(hist(deg, plot=FALSE)$counts) * 0.6, 
     "50%", col="blue")
text(quantiles[3] - 0.5, max(hist(deg, plot=FALSE)$counts) * 0.5, 
     "75%", col="blue")
```

```{r}
# For part 2: Study relationship between clustering coefficient and p
p_values <- seq(0.01, 0.5, by = 0.05)

Regular<-watts.strogatz.game(dim=1,size=300,nei=6, p=0.01)


# Calculate the distribution of shortest path lengths
dist_matrix <- distances(Regular)
path_lengths <- dist_matrix[lower.tri(dist_matrix)]
path_lengths <- path_lengths[is.finite(path_lengths)]  # Remove Inf values if any

# Plot the relationship
par(mfrow = c(1, 1))
plot(p_values, clustering_coeffs, type = "b", 
     xlab = "Probability (p)", ylab = "Clustering Coefficient",
     main = "Relationship between p and Clustering Coefficient")

Regular<-watts.strogatz.game(dim=1,size=300,nei=6, p=0)
plot(Regular)

```

