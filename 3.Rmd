---
title: "Exercise3"
author: "Hein Brouwer"
date: "2025-04-03"
output: pdf_document
---

```{r}
library(igraph)
library(visNetwork)
library(data.table)
library(Matrix)
library(dplyr)
library(ggplot2)
```


```{r}
# Import the data
data <- read.csv("ClassHNA.csv", row.names = 1)
# Convert to matrix
adj_matrix <- as.matrix(data)
# Create graph from adjacency matrix
ClassHNA <- graph_from_adjacency_matrix(adj_matrix, mode = "undirected", diag = FALSE)

# visualization code
set.seed(100)
ClassHNA_interactive_layout <- visNetwork::visIgraph(ClassHNA) %>%
  visIgraphLayout(layout = "layout_nicely", smooth = FALSE) %>%
  visNodes(shape = "circle", label = TRUE) %>%
  visOptions(highlightNearest = list(enabled = T, hover = T), nodesIdSelection = T)

# Using the provided IC model function
calculate_value <- function(node, each_neighbors, Pprob) {
  return(each_neighbors[[node]][which(runif(length(each_neighbors[[node]]), 0, 1) <= Pprob)])
}

IC <- function(node_seed, network, Pprob) {
  # Prepare input for the 'calculate_value' function
  adj_matrix <- igraph::as_adjacency_matrix(network, type = 'both')
  each_neighbors <- which(adj_matrix > 0, arr.ind = TRUE)
  each_neighbors <- split(each_neighbors[, 2], each_neighbors[, 1]) # Get the neighbor list of each node
  
  nNode <- vcount(network)
  node_status <- rep.int(0, nNode) # Start from a healthy population
  day_infected <- vector() # Total number of infected population
  new_infected <- list() # Record the ID of person getting infected at each time step
  
  day <- 1
  node_status[as.numeric(node_seed)] <- 1 # infected(value=1) health(value=0)
  day_infected[day] <- sum(node_status)
  new_infected[[day]] <- node_seed # The ID of the person infected in Day 1 (Patient Zero)
  
  # Simulate the spread of virus within 4 weeks
  for (day in c(2:28)) {
    ContagiousID <- which(node_status == 1)
    infectedID <- unlist(lapply(ContagiousID, calculate_value, each_neighbors, Pprob))
    newinfectedID <- setdiff(infectedID, which(node_status == 1))
    
    # Update the node status and other variables
    node_status[newinfectedID] <- 1
    day_infected[day] <- length(newinfectedID)
    new_infected[[day]] <- newinfectedID
    
    day <- day + 1
  }
  
  return(day_infected) # Return the number of newly infected people by day
}

# Run the IC model 100 times and take the average results
run_multiple_ic <- function(seed_node, network, prob, times = 100) {
  results <- matrix(0, nrow = times, ncol = 28)
  for (i in 1:times) {
    results[i, ] <- IC(seed_node, network, prob)
  }
  return(colMeans(results))
}

# Run the simulation with the parameters specified in the question
set.seed(123)
avg_results <- run_multiple_ic(20, ClassHNA, 0.0075)
print(avg_results) # Show the average number of newly infected people by day

# Plot the results
plot(1:28, avg_results, type = "l", xlab = "Day", ylab = "Newly Infected People",
     main = "Average Number of Newly Infected People by Day (100 simulations)")

# Total number of infections
cat("Total infections over 28 days:", sum(avg_results))
```
```{r}
library(igraph)
library(visNetwork)
library(data.table)
library(Matrix)
library(dplyr)
library(ggplot2)

# Import the data
data <- read.csv("ClassHNA.csv", row.names = 1)
# Convert to matrix
adj_matrix <- as.matrix(data)
# Create graph from adjacency matrix
ClassHNA <- graph_from_adjacency_matrix(adj_matrix, mode = "undirected", diag = FALSE)

# Function to calculate which neighbors get infected (from example)
calculate_value <- function(node, each_neighbors, Pprob) {
  return(each_neighbors[[node]][which(runif(length(each_neighbors[[node]]), 0, 1) <= Pprob)])
}

# Independent Cascade model (using the exact example code)
IC <- function(node_seed, network, Pprob) {
  # Prepare input for the 'calculate_value' function
  adj_matrix <- igraph::as_adjacency_matrix(network, type = 'both')
  each_neighbors <- which(adj_matrix > 0, arr.ind = TRUE)
  each_neighbors <- split(each_neighbors[, 2], each_neighbors[, 1]) # Get the neighbor list of each node
  
  nNode <- vcount(network)
  node_status <- rep.int(0, nNode) # Start from a healthy population
  day_infected <- vector() # Total number of infected population
  new_infected <- list() # Record the ID of person getting infected at each time step
  
  day <- 1
  node_status[as.numeric(node_seed)] <- 1 # infected(value=1) health(value=0)
  day_infected[day] <- sum(node_status)
  new_infected[[day]] <- node_seed # The ID of the person infected in Day 1 (Patient Zero)
  
  # Simulate the spread of virus within 4 weeks
  for (day in c(2:28)) {
    ContagiousID <- which(node_status == 1)
    infectedID <- unlist(lapply(ContagiousID, calculate_value, each_neighbors, Pprob))
    newinfectedID <- setdiff(infectedID, which(node_status == 1))
    
    # Update the node status and other variables
    node_status[newinfectedID] <- 1
    day_infected[day] <- length(newinfectedID)
    new_infected[[day]] <- newinfectedID
    
    day <- day + 1
  }
  
  return(day_infected) # Return the number of newly infected people by day
}

# Find and sort edges by betweenness
edge_betw <- edge_betweenness(ClassHNA)

# Create edge IDs for the 5 highest and 5 lowest betweenness edges
high_betw_edges <- order(edge_betw, decreasing = TRUE)[1:5]
low_betw_edges <- order(edge_betw)[1:5]

# Get the endpoints for the high betweenness edges (weak ties)
cat("Weak ties (identified by highest betweenness):\n")
for (i in high_betw_edges) {
  ends_i <- ends(ClassHNA, i)
  cat("Edge", i, "connects vertices", ends_i[1], "and", ends_i[2], "\n")
}

# Get the endpoints for the low betweenness edges (strong ties)
cat("Strong ties (identified by lowest betweenness):\n")
for (i in low_betw_edges) {
  ends_i <- ends(ClassHNA, i)
  cat("Edge", i, "connects vertices", ends_i[1], "and", ends_i[2], "\n")
}

# Create new networks by deleting the identified edges
# For weak ties
ClassHNA2 <- delete_edges(ClassHNA, high_betw_edges)

# For strong ties
ClassHNA3 <- delete_edges(ClassHNA, low_betw_edges)

# Run the IC model 100 times on each network and take the average
run_multiple_simulations <- function(network, seed_node, prob, times = 100) {
  results <- matrix(0, nrow = times, ncol = 28)
  for (i in 1:times) {
    results[i, ] <- IC(seed_node, network, prob)
  }
  return(colMeans(results))
}

set.seed(123)
results_original <- run_multiple_simulations(ClassHNA, 20, 0.0075)
results_weak_removed <- run_multiple_simulations(ClassHNA2, 20, 0.0075)
results_strong_removed <- run_multiple_simulations(ClassHNA3, 20, 0.0075)

# Create a data frame for plotting
results_df <- data.frame(
  day = rep(1:28, 3),
  newly_infected = c(results_original, results_weak_removed, results_strong_removed),
  network = factor(c(rep("Original", 28), rep("Weak Ties Removed", 28), rep("Strong Ties Removed", 28)),
                   levels = c("Original", "Weak Ties Removed", "Strong Ties Removed"))
)

# Plot the results
ggplot(results_df, aes(x = day, y = newly_infected, color = network)) +
  geom_line() +
  labs(title = "Impact of Removing Weak vs. Strong Ties on Contagion Spread",
       x = "Day", 
       y = "Newly Infected People",
       color = "Network") +
  theme_minimal()

# Calculate cumulative infections
cumulative_original <- sum(results_original)
cumulative_weak_removed <- sum(results_weak_removed)
cumulative_strong_removed <- sum(results_strong_removed)

cat("Total infections in original network:", cumulative_original, "\n")
cat("Total infections with weak ties removed:", cumulative_weak_removed, "\n")
cat("Total infections with strong ties removed:", cumulative_strong_removed, "\n")
```
```{r}
library(igraph)
library(visNetwork)
library(data.table)
library(Matrix)
library(dplyr)
library(ggplot2)

# Import the data
data <- read.csv("ClassHNA.csv", row.names = 1)
# Convert to matrix
adj_matrix <- as.matrix(data)
# Create graph from adjacency matrix
ClassHNA <- graph_from_adjacency_matrix(adj_matrix, mode = "undirected", diag = FALSE)

# Import thresholds
ClassHNA_att <- read.csv("ClassHNA_att.csv")
threshold <- ClassHNA_att$Threshold

# Threshold Model functions (using the exact example code)
calculate_adoptedNei <- function(node, node_status, each_neighbors) {
  return(sum(node_status[each_neighbors[[node]]] == 1)) # Calculate the sum of adopted neighbors
}

ThModel <- function(node_seed, network, threshold) {
  # Prepare input for the 'calculate_value' function
  adj_matrix <- igraph::as_adjacency_matrix(network, type = 'both')
  each_neighbors <- which(adj_matrix > 0, arr.ind = TRUE)
  each_neighbors <- split(each_neighbors[, 2], each_neighbors[, 1]) # Get the neighbor list of each node
  
  nNode <- vcount(network)
  node_status <- rep.int(0, nNode)
  neighbour_status <- rep.int(0, nNode) # Percentage of adopted neighbors
  new_infected <- list()
  day_total_infected <- rep(0, 28) # Total number of active people by end of each day
  
  # Day 1
  day <- 1
  node_status[as.numeric(node_seed)] <- 1
  new_infected[[day]] <- node_seed
  day_total_infected[day] <- sum(node_status == 1)
  
  # Subsequent days
  for (day in 2:28) {
    NotAdopted <- which(node_status == 0)
    Adopted <- which(node_status == 1)
    
    neighbour_status[NotAdopted] <- unlist(lapply(NotAdopted, calculate_adoptedNei,
                                                node_status, each_neighbors))
    
    new_infected[[day]] <- setdiff(which(neighbour_status > threshold), Adopted)
    node_status[new_infected[[day]]] <- 1 # Update the status to 1 for those newly adopted
    day_total_infected[day] <- sum(node_status)
    
    day <- day + 1
  }
  
  return(list(day_total_infected, new_infected))
}

# Greedy Algorithm (using the exact example code)
greedy_ThM <- function(network, threshold, k) {
  nNode <- vcount(network)
  SeedCan <- c(1:nNode) # Nodes that can still be used as seeds
  Seedset <- c() # Nodes that will be used as seeds
  
  for (s in 1:k) {
    best_seed <- -1 # Initial setting of each round
    best_spread <- -Inf
    
    N <- length(SeedCan)
    for (i in 1:N) {
      current_seed <- SeedCan[i]
      current_seedset <- c(Seedset, current_seed)
      current_spread <- ThModel(current_seedset, network, threshold)[[1]]
      if (sum(current_spread) > sum(best_spread)) {
        best_seed <- current_seed
        best_spread <- current_spread
      }
    }
    Seedset <- c(Seedset, best_seed)
    SeedCan <- setdiff(SeedCan, Seedset) # Exclude the seed nodes in next round seed selection
  }
  return(Seedset)
}

# 1. Degree Heuristic: Select nodes with highest degree
degree_heuristic <- function(network, k) {
  node_degrees <- degree(network)
  return(order(node_degrees, decreasing = TRUE)[1:k])
}

# 2. Betweenness Heuristic: Select nodes with highest betweenness centrality
betweenness_heuristic <- function(network, k) {
  node_betweenness <- betweenness(network)
  return(order(node_betweenness, decreasing = TRUE)[1:k])
}

# Apply the three methods to select 2 seed nodes
seeds_degree <- degree_heuristic(ClassHNA, 2)
seeds_betweenness <- betweenness_heuristic(ClassHNA, 2)
seeds_greedy <- greedy_ThM(ClassHNA, threshold, 2)

# Run the threshold model with each set of seed nodes
results_degree <- ThModel(seeds_degree, ClassHNA, threshold)[[1]]
results_betweenness <- ThModel(seeds_betweenness, ClassHNA, threshold)[[1]]
results_greedy <- ThModel(seeds_greedy, ClassHNA, threshold)[[1]]

# Print the seed nodes and their overall performance
cat("Seeds selected by Degree Heuristic:", seeds_degree, "\n")
cat("Seeds selected by Betweenness Heuristic:", seeds_betweenness, "\n")
cat("Seeds selected by Greedy Algorithm:", seeds_greedy, "\n")

cat("\nTotal adoption at the end:\n")
cat("Degree Heuristic:", results_degree[28], "\n")
cat("Betweenness Heuristic:", results_betweenness[28], "\n")
cat("Greedy Algorithm:", results_greedy[28], "\n")

# Create a data frame for plotting
results_df <- data.frame(
  day = rep(1:28, 3),
  total_adopted = c(results_degree, results_betweenness, results_greedy),
  method = factor(c(rep("Degree", 28), rep("Betweenness", 28), rep("Greedy", 28)),
                  levels = c("Degree", "Betweenness", "Greedy"))
)

# Plot the results to compare the three methods
ggplot(results_df, aes(x = day, y = total_adopted, color = method)) +
  geom_line() +
  labs(title = "Comparison of Seed Selection Methods for Influence Maximization",
       x = "Day", 
       y = "Total Number of Adopters",
       color = "Method") +
  theme_minimal()
```


